<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/theme/css/elegant.prod.9e9d5ce754.css" media="screen">
        <link rel="stylesheet" type="text/css" href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/theme/css/custom.css" media="screen">

        <link rel="dns-prefetch" href="//fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>

        <meta name="author" content="MFIN7036 Students 2025" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="Group "SFinx", Progress Report 2, " />

<meta property="og:title" content="Clustering with Sentiment Analysis and Market Analysis (by Group &#34;SFinx&#34;) "/>
<meta property="og:url" content="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/clustering-with-sentiment-analysis-and-market-analysis-by-group-sfinx.html" />
<meta property="og:description" content="Text Processing After scraping news data from Reuters, we perform text processing to clean and refine the content, preparing it for subsequent vectorization and clustering. Since the data collection phase already involved preprocessing and integration into a JSON file format (as mentioned in the first blog), this step primarily focuses …" />
<meta property="og:site_name" content="MFIN7036 Student Blog 2025" />
<meta property="og:article:author" content="MFIN7036 Students 2025" />
<meta property="og:article:published_time" content="2025-03-10T00:00:00+08:00" />
<meta name="twitter:title" content="Clustering with Sentiment Analysis and Market Analysis (by Group &#34;SFinx&#34;) ">
<meta name="twitter:description" content="Text Processing After scraping news data from Reuters, we perform text processing to clean and refine the content, preparing it for subsequent vectorization and clustering. Since the data collection phase already involved preprocessing and integration into a JSON file format (as mentioned in the first blog), this step primarily focuses …">

        <title>Clustering with Sentiment Analysis and Market Analysis (by Group &#34;SFinx&#34;)  · MFIN7036 Student Blog 2025
</title>
        <link href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="MFIN7036 Student Blog 2025 - Full Atom Feed" />



    </head>
    <body>
        <div id="content">
            <div class="navbar navbar-static-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/"><span class=site-name>MFIN7036 Student Blog 2025</span></a>
                        <div class="nav-collapse collapse">
                            <ul class="nav pull-right top-menu">
                                <li >
                                    <a href=
                                       https://buehlmaier.github.io/MFIN7036-student-blog-2025-01
                                    >Home</a>
                                </li>
                                <li ><a href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/categories.html">Categories</a></li>
                                <li ><a href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/tags.html">Tags</a></li>
                                <li ><a href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/archives.html">Archives</a></li>
                                <li><form class="navbar-search" action="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container-fluid">
                <div class="row-fluid">
                    <div class="span1"></div>
                    <div class="span10">
<article itemscope>
<div class="row-fluid">
    <header class="page-header span10 offset2">
        <h1>
            <a href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/clustering-with-sentiment-analysis-and-market-analysis-by-group-sfinx.html">
                Clustering with Sentiment Analysis and Market Analysis (by Group "SFinx")
            </a>
        </h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">
            
            <h2>Text Processing</h2>
<p>After scraping news data from Reuters, we perform text processing to clean and refine the content, preparing it for subsequent vectorization and clustering. Since the data collection phase already involved preprocessing and integration into a <code>JSON file</code> format (as mentioned in the first blog), this step primarily focuses on processing the article body to enhance its suitability for vectorization. </p>
<h4>Key steps include:</h4>
<ol>
<li>
<p><strong>Text Cleaning</strong>: Remove HTML tags, special characters, numbers, and normalize whitespace.</p>
</li>
<li>
<p><strong>Tokenization &amp; Filtering</strong>: Use regex-based tokenization to retain words with ≥2 letters, remove standard English stopwords(198) and custom stopwords (e.g., country names, dates, prepositions with 100+), and filter out long words (&gt;10 letters).</p>
</li>
<li>
<p><strong>Lemmatization</strong>: Perform context-aware lemmatization (e.g., <code>running</code> → <code>run</code>) using POS tagging to map words to their base forms accurately.</p>
</li>
<li>
<p><strong>Data Integration</strong>: Process titles and bodies from JSON files, skip non-English or empty articles, and deduplicate based on titles.</p>
</li>
<li>
<p><strong>Format Conversion</strong>: Convert tokenized results into comma-separated strings and save as structured CSV.</p>
</li>
</ol>
<p><em>Note: Since the code is too lengthy, please refer to our <a href="https://github.com/hanhy/MFIN7036/tree/regina_dev/group_project/Text%20Preprocessing">GitHub repository</a> (Text_Preprocessing_V2) for the relevant implementation.</em></p>
<h3>Challenges &amp; Solutions</h3>
<p>To further refine text quality, three targeted filtering steps were implemented to eliminate noise identified through iterative testing:</p>
<h4>1. Residual Stop Words</h4>
<p><strong>Issue</strong>: Default stopword lists (NLTK) missed domain-specific terms (e.g., <code>china</code>, <code>jan</code>).</p>
<p><strong>Solution</strong>: Expanded custom stopwords to include countries, dates, redundant terms (e.g., <code>new</code>, <code>say</code>), and prepositions—over 200 terms added.</p>
<div class="highlight"><pre><span></span><code><span class="n">stop_words</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">stopwords</span><span class="o">.</span><span class="n">words</span><span class="p">(</span><span class="s1">&#39;english&#39;</span><span class="p">))</span>
<span class="n">custom_prepositions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;above&#39;</span><span class="p">,</span> <span class="s1">&#39;across&#39;</span><span class="p">,</span> <span class="s1">&#39;after&#39;</span><span class="p">,</span><span class="o">...</span><span class="p">}</span>
<span class="n">custom_stop_words</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;china&#39;</span><span class="p">,</span> <span class="s1">&#39;usa&#39;</span><span class="p">,</span><span class="s1">&#39;say&#39;</span><span class="p">,</span> <span class="s1">&#39;jan&#39;</span><span class="p">,</span><span class="o">...</span><span class="p">}</span>
<span class="n">stop_words</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">custom_prepositions</span><span class="p">)</span>
<span class="n">stop_words</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">custom_stop_words</span><span class="p">)</span>
<span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">tokens</span> <span class="k">if</span> <span class="n">word</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stop_words</span><span class="p">]</span>
</code></pre></div>

<h4>2. Single-Letter Word Elimination</h4>
<p><strong>Issue</strong>: Despite initial tokenization rules (retaining ≥2-letter words), residual single-letter tokens like <code>u</code> appeared after lemmatization.</p>
<p><strong>Solution</strong>: Added a final filter to enforce a minimum word length of 2 characters.</p>
<div class="highlight"><pre><span></span><code><span class="n">lemmatized_tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">lemmatized_tokens</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div>

<h4>3. Post-Lemmatization Specific Word Removal</h4>
<p><strong>Iteration Process:</strong></p>
<p><strong>V1</strong>: Removed common noisy words (e.g., <code>licensing</code>, <code>right</code>) early in preprocessing.</p>
<p><strong>V2</strong>: Found residual terms like <code>principle</code> and <code>new</code> persisting after lemmatization. Revised the code to apply removal after lemmatization for completeness.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Remove specific words (performed after lemmatization)</span>
<span class="n">words_to_remove</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;licensing&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;thomson&#39;</span><span class="p">,</span> <span class="s1">&#39;trust&#39;</span><span class="p">,</span> <span class="s1">&#39;tabsuggested&#39;</span><span class="p">,</span> 
                   <span class="s1">&#39;principle&#39;</span><span class="p">,</span> <span class="s1">&#39;open&#39;</span><span class="p">,</span> <span class="s1">&#39;new&#39;</span><span class="p">,</span> <span class="s1">&#39;standard&#39;</span><span class="p">,</span> <span class="s1">&#39;say&#39;</span><span class="p">,</span> <span class="s1">&#39;co&#39;</span><span class="p">,</span> <span class="s1">&#39;ltd&#39;</span><span class="p">}</span>
<span class="n">lemmatized_tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">lemmatized_tokens</span> <span class="k">if</span> <span class="n">word</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">words_to_remove</span><span class="p">]</span>
</code></pre></div>

<h3>Key Design Choices</h3>
<p><strong>Multi-Stage Filtering</strong>: Progressive refinement via cleaning → stopword removal → length filtering → post-lemmatization pruning.</p>
<p><strong>POS-Guided Lemmatization</strong>: Leveraged part-of-speech tagging for context-aware lemmatization, outperforming single-POS assumptions.</p>
<p><strong>Lightweight Structuring</strong>: Output CSV retains only essential fields (title, date, body) to streamline downstream vectorization. Part of the CSV results is shown below:
<img alt="image one" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/images/SFinx_02_image-descriptionone.png"> </p>
<h2>Clustering</h2>
<p>After text preprocessing, we employ TF-IDF vectorization to transform text into numerical representations, capturing key features for analysis. In the clustering phase, we utilize K-Means to identify distinct themes within financial news. This section outlines the code configuration and parameter tuning, ensuring efficient and insightful classification of financial news data.</p>
<h3>Step 1: Word2Vec Model Training</h3>
<p>To capture semantic relationships between words, we trained a Word2Vec model on the preprocessed text corpus. Key hyperparameters were systematically tuned to balance model performance and computational efficiency:</p>
<ul>
<li><strong>vector_size(70–90)</strong>: Controls the dimensionality of word embeddings. Higher values capture finer semantic nuances but increase complexity.</li>
<li><strong>window(8–10)</strong>: Defines the context window size for training. Larger windows capture broader document-level themes.</li>
<li><strong>min_count(2–3)</strong>: Filters out rare words to reduce noise while retaining domain-specific terms.</li>
<li><strong>N(10–20)</strong>: To find the best number of important words that we should select from each document.</li>
</ul>
<p><strong>The goal of this part is to find the best parameters combination to find the meaningful words.</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># The best parameters combination to train the Word2Vec Model</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Word2Vec</span><span class="p">(</span><span class="n">sentences</span><span class="o">=</span><span class="n">test_data</span><span class="p">[</span><span class="s1">&#39;content_tokens&#39;</span><span class="p">],</span> <span class="n">vector_size</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
</code></pre></div>

<p><em>Note: Since the code is too lengthy, please refer to our <a href="https://github.com/hanhy/MFIN7036/blob/makm_dev/group_project/Vectorization%2BClustering/find_parameter.ipynb">GitHub repository</a> (find_parameter) for the relevant implementation.</em></p>
<h3>Step 2: Clustering by K-means</h3>
<h4>Extracting Important Words with TF-IDF</h4>
<p>After training the Word2Vec model, we used <strong>TF-IDF</strong> (Term Frequency-Inverse Document Frequency) to rank word importance within each document. We select the 20 most frequent words per article (based on inverse TF-IDF scores).</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Compute TF-IDF weights for all words in the dataset</span>
<span class="n">corpus</span> <span class="o">=</span> <span class="n">test_data</span><span class="p">[</span><span class="s1">&#39;content&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>  
<span class="n">vectorizer</span> <span class="o">=</span> <span class="n">TfidfVectorizer</span><span class="p">()</span>
<span class="n">tfidf_matrix</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>
<span class="n">word2tfidf</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">get_feature_names_out</span><span class="p">(),</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">idf_</span><span class="p">))</span>

<span class="c1"># Identify high-frequency words per article</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">20</span> <span class="c1"># Number of top words per article, N also be found by the loop function</span>
<span class="n">test_data</span><span class="p">[</span><span class="s1">&#39;important_words&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">test_data</span><span class="p">[</span><span class="s1">&#39;content_tokens&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">tokens</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="nb">set</span><span class="p">(</span><span class="n">tokens</span><span class="p">),</span>  <span class="c1"># Remove duplicates</span>
        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">word2tfidf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># Rank by TF-IDF score</span>
        <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span>  <span class="c1"># Lower TF-IDF means higher frequency in this case</span>
    <span class="p">)[:</span><span class="n">N</span><span class="p">]</span>
<span class="p">)</span>
</code></pre></div>

<h4>Converting Text into Feature Vectors</h4>
<p>Each document is represented as a weighted average of its word embeddings. This transforms unstructured text into <strong>numerical vectors</strong> suitable for clustering.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Define a function to convert text to a weighted vector, use the word2vec model and the TF-IDF weights</span>
<span class="k">def</span> <span class="nf">text_to_vector</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">word2tfidf</span><span class="p">):</span>
    <span class="n">vectors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">wv</span><span class="p">:</span>
            <span class="n">vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">wv</span><span class="p">[</span><span class="n">word</span><span class="p">])</span>
            <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word2tfidf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>  <span class="c1"># Default weight 1.0 if not in TF-IDF</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">vectors</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">vector_size</span><span class="p">)</span>
    <span class="n">vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  <span class="c1"># Normalize weights</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

<span class="c1"># Convert important words to vectors</span>
<span class="n">test_data</span><span class="p">[</span><span class="s1">&#39;vector&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">test_data</span><span class="p">[</span><span class="s1">&#39;important_words&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">text_to_vector</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">word2tfidf</span><span class="p">))</span>
</code></pre></div>

<h4>K-Means Clustering</h4>
<p>We partitioned the documents into clusters using K-Means with <code>num_clusters=2</code>. Key steps included: 1. Scaling feature vectors to ensure equal contribution from all dimensions. 2. Running multiple initializations to avoid suboptimal local minima.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Use the k-means algorithm to cluster the articles, split the data into two groups.</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_data</span><span class="p">[</span><span class="s1">&#39;vector&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
<span class="n">num_clusters</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Number of clusters</span>
<span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">num_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">test_data</span><span class="p">[</span><span class="s1">&#39;cluster_label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span>
</code></pre></div>

<h4>Evaluating Clustering Performance</h4>
<p>We use two metrics: 1. Silhouette Score: Measures how well clusters are separated. 2. Calinski-Harabasz Score: Evaluates the compactness of clusters. The best hyperparameters are chosen based on these scores.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Evaluate clustering effect by calculating silhouette score and Calinski-Harabasz index</span>
<span class="k">if</span> <span class="s1">&#39;cluster_label&#39;</span> <span class="ow">in</span> <span class="n">test_data</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">test_data</span><span class="p">[</span><span class="s1">&#39;cluster_label&#39;</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_data</span><span class="p">[</span><span class="s1">&#39;vector&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>  <span class="c1"># Assuming &#39;vector&#39; is from the Word2Vec/KMeans pipeline</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">test_data</span><span class="p">[</span><span class="s1">&#39;cluster_label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">silhouette</span> <span class="o">=</span> <span class="n">silhouette_score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
    <span class="n">ch_score</span> <span class="o">=</span> <span class="n">calinski_harabasz_score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Silhouette Score: </span><span class="si">{</span><span class="n">silhouette</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calinski-Harabasz Index: </span><span class="si">{</span><span class="n">ch_score</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unable to calculate clustering metrics: Either no &#39;cluster_label&#39; column or fewer than 2 clusters.&quot;</span><span class="p">)</span>
</code></pre></div>

<ul>
<li><strong>WordCloud of Each Cluster</strong>: Generate the WordCloud for the high-frequency words in each cluster, based on data from January 2021 to August 2021, to visualize the details of each cluster.</li>
</ul>
<p><img alt="image two" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/images/SFinx_02_image-descriptiontwo.png"></p>
<p><img alt="image three" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/images/SFinx_02_image-descriptionthree.png"> </p>
<h2>Sentiment Analysis</h2>
<p>In this analysis, we used two sentiment analysis tools—VADER (general-purpose) and FinBERT (finance-specific)—to evaluate their effectiveness in extracting actionable insights from financial news clusters. Using a dataset of Reuters articles grouped into thematic clusters via K-Means, we measured sentiment polarity across clusters and dates. </p>
<h3>Method 1: VADER for general sentiment analysis</h3>
<p><strong>VADER</strong> (Valence Aware Dictionary and sEntiment Reasoner) is a <strong>lexicon and rule-based</strong> sentiment analysis tool. It is specifically designed to analyze the sentiment of text in social media and other informal contexts. It works by looking at the words and phrases in the text, and then assigning sentiment scores based on a pre-defined dictionary of sentiment-laden words and a set of rules for combining those scores. Key advantages of VADER include its suitability for general text analysis and its speed and efficiency in processing large volumes of data.</p>
<p>Key Implementation Steps:</p>
<ol>
<li>
<p>Date-Cluster Grouping: Group articles by publication date and predefined thematic clusters (e.g., "Monetary Policy" vs. "Market Risks").</p>
</li>
<li>
<p>TF-IDF Weighted Keywords: Extract top 20 keywords per article using inverse document frequency (IDF) to prioritize rare yet impactful  terms. Calculate normalized TF-IDF weights for each keyword to reflect its contextual relevance.</p>
</li>
<li>
<p>Contextual Text Synthesis: Convert keyword lists into synthetic text snippets (e.g., <code>["inflation", "rate hike"]</code> → <code>"inflation rate hike"</code>).</p>
</li>
<li>
<p>Sentiment Scoring: Apply VADER’s rule-based polarity detection to each synthetic snippet.
Compute weighted compound scores using:
<div class="math">$$
\text{Weighted Score} = \sum (\text{Word Sentiment} \times \text{TF-IDF Weight})
$$</div>
</p>
</li>
<li>
<p>Temporal Aggregation: Calculate daily average sentiment scores per cluster, weighted by article frequency. Handle edge cases (e.g., empty articles) with zero-filling to maintain temporal continuity.</p>
</li>
</ol>
<p>These code briefly introduces a framework of VADER and its application in sentiment analysis:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Method 1: Use VADER to analyze sentiment of important words in each cluster</span>
<span class="n">test_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">test_data</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">])</span>
<span class="n">grouped</span> <span class="o">=</span> <span class="n">test_data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;date&#39;</span><span class="p">)</span>

<span class="c1"># Initialize VADER sentiment analyzer</span>
<span class="n">analyzer</span> <span class="o">=</span> <span class="n">SentimentIntensityAnalyzer</span><span class="p">()</span>
<span class="c1"># Store daily sentiment results for each cluster</span>
<span class="n">sentiment_results</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">date</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_clusters</span><span class="p">):</span>
        <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">group</span><span class="p">[</span><span class="s1">&#39;cluster_label&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">]</span>
        <span class="n">sentiment_scores</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">important_words</span> <span class="ow">in</span> <span class="n">cluster_data</span><span class="p">[</span><span class="s1">&#39;important_words&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">important_words</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">words</span> <span class="o">=</span> <span class="p">[</span><span class="n">word</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">important_words</span> <span class="k">if</span> <span class="n">word</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stop_words</span> <span class="ow">and</span> <span class="n">word</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>  

            <span class="k">if</span> <span class="ow">not</span> <span class="n">words</span><span class="p">:</span>
                <span class="k">continue</span>  

            <span class="c1"># calculate word weights based on TF-IDF scores</span>
            <span class="n">word_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">word2tfidf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">])</span>

            <span class="c1"># Normalize word weights to sum to 1</span>
            <span class="k">if</span> <span class="n">word_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">word_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">word_weights</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">word_weights</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">word_weights</span> <span class="o">/=</span> <span class="n">word_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">sentiment</span> <span class="o">=</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">polarity_scores</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
                <span class="n">compound_score</span> <span class="o">=</span> <span class="n">sentiment</span><span class="p">[</span><span class="s1">&#39;compound&#39;</span><span class="p">]</span>
                <span class="n">positive_score</span> <span class="o">=</span> <span class="n">sentiment</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span>
                <span class="n">negative_score</span> <span class="o">=</span> <span class="n">sentiment</span><span class="p">[</span><span class="s1">&#39;neg&#39;</span><span class="p">]</span>
                <span class="n">neutral_score</span> <span class="o">=</span> <span class="n">sentiment</span><span class="p">[</span><span class="s1">&#39;neu&#39;</span><span class="p">]</span>

                <span class="c1"># Calculate weighted sentiment scores</span>
                <span class="n">weighted_sentiment</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;compound&#39;</span><span class="p">:</span> <span class="n">compound_score</span> <span class="o">*</span> <span class="n">word_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
                    <span class="s1">&#39;positive&#39;</span><span class="p">:</span> <span class="n">positive_score</span> <span class="o">*</span> <span class="n">word_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
                    <span class="s1">&#39;negative&#39;</span><span class="p">:</span> <span class="n">negative_score</span> <span class="o">*</span> <span class="n">word_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span>
                    <span class="s1">&#39;neutral&#39;</span><span class="p">:</span> <span class="n">neutral_score</span> <span class="o">*</span> <span class="n">word_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="p">}</span>

                <span class="n">sentiment_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weighted_sentiment</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing text for date </span><span class="si">{</span><span class="n">date</span><span class="si">}</span><span class="s2">, cluster </span><span class="si">{</span><span class="n">cluster</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">text</span><span class="p">[:</span><span class="mi">50</span><span class="p">]</span><span class="si">}</span><span class="s2">..., Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>


        <span class="c1"># Calculate average sentiment scores</span>
        <span class="k">if</span> <span class="n">sentiment_scores</span><span class="p">:</span>
            <span class="n">avg_sentiment</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;compound&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;compound&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sentiment_scores</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="n">word_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentiment_scores</span><span class="p">)),</span>
                <span class="s1">&#39;positive&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;positive&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sentiment_scores</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="n">word_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentiment_scores</span><span class="p">)),</span>
                <span class="s1">&#39;negative&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;negative&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sentiment_scores</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="n">word_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentiment_scores</span><span class="p">)),</span>
                <span class="s1">&#39;neutral&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;neutral&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sentiment_scores</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="n">word_weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentiment_scores</span><span class="p">))</span>
            <span class="p">}</span>

            <span class="n">sentiment_results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="n">date</span><span class="p">,</span>
                <span class="s1">&#39;cluster&#39;</span><span class="p">:</span> <span class="n">cluster</span><span class="p">,</span>
                <span class="s1">&#39;sentiment_score&#39;</span><span class="p">:</span> <span class="n">avg_sentiment</span><span class="p">[</span><span class="s1">&#39;compound&#39;</span><span class="p">],</span>
                <span class="s1">&#39;positive_score&#39;</span><span class="p">:</span> <span class="n">avg_sentiment</span><span class="p">[</span><span class="s1">&#39;positive&#39;</span><span class="p">],</span>
                <span class="s1">&#39;negative_score&#39;</span><span class="p">:</span> <span class="n">avg_sentiment</span><span class="p">[</span><span class="s1">&#39;negative&#39;</span><span class="p">],</span>
                <span class="s1">&#39;neutral_score&#39;</span><span class="p">:</span> <span class="n">avg_sentiment</span><span class="p">[</span><span class="s1">&#39;neutral&#39;</span><span class="p">],</span>
                <span class="s1">&#39;num_samples&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentiment_scores</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sentiment_results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;date&#39;</span><span class="p">:</span> <span class="n">date</span><span class="p">,</span>
                <span class="s1">&#39;cluster&#39;</span><span class="p">:</span> <span class="n">cluster</span><span class="p">,</span>
                <span class="s1">&#39;sentiment_score&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                <span class="s1">&#39;positive_score&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                <span class="s1">&#39;negative_score&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                <span class="s1">&#39;neutral_score&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                <span class="s1">&#39;num_samples&#39;</span><span class="p">:</span> <span class="mi">0</span>
            <span class="p">})</span>

<span class="c1"># Create DataFrame from sentiment results</span>
<span class="n">vade_sentiment_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">sentiment_results</span><span class="p">)</span>

<span class="c1"># Print results</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Sentiment Analysis Results:&quot;</span><span class="p">)</span>
<span class="n">vade_sentiment_df</span>
</code></pre></div>

<h3>Method 2: FinBERT for financial sentiment analysis</h3>
<p><strong>FinBERT</strong> is a sentiment analysis model based on the <strong>BERT</strong> (Bidirectional Encoder Representations from Transformers) architecture, specifically fine-tuned for <strong>financial text</strong>. It is used to analyze the sentiment of financial news, reports, earnings calls, and other financial-related text. It can understand the context and semantics of financial language, and classify the text into positive, negative, or neutral sentiment categories. Its key advantages include high accuracy in the financial domain, strong contextual understanding, and robust generalization ability across various financial texts.</p>
<p>Using HuggingFace’s <code>AutoTokenizer</code> and <code>AutoModelForSequenceClassification</code>, we load the pre-trained weights of the <code>yiyanghkust/finbert-tone</code> model, which is explicitly fine-tuned to recognize financial jargon (e.g., "quantitative easing," "bear market") and contextual nuances in economic narratives. </p>
<p>The following are the code for Model Initialization:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Method 2: Use FinBERT for sentiment analysis</span>
<span class="c1"># Load FinBERT model and tokenizer</span>
<span class="n">model_name</span> <span class="o">=</span> <span class="s2">&quot;yiyanghkust/finbert-tone&quot;</span>  <span class="c1"># FinBERT model fine-tuned for financial sentiment</span>
<span class="n">tokenizer</span> <span class="o">=</span> <span class="n">AutoTokenizer</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">AutoModelForSequenceClassification</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>
</code></pre></div>

<h4>Result</h4>
<p>Each date - cluster pair is associated with an average sentiment score. A comparison of the results obtained from VADER and FinBERT reveals that Cluster 0 has a higher proportion of positive scores than Cluster 1. Moreover, the results from FinBERT appear to be more accurate or of better quality than those from VADER.</p>
<ul>
<li><strong>Results from VADER</strong> (Based on Data from January 2021 to August 2021)</li>
</ul>
<p><img alt="image four" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/images/SFinx_02_image-descriptionfour.png"> </p>
<ul>
<li><strong>Result from FinBert</strong> (Based on Data from January 2021 to August 2021)</li>
</ul>
<p><img alt="image five" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/images/SFinx_02_image-descriptionfive.png"> </p>
<h2>Processing of Market Data</h2>
<h3>Fetching Financial Data</h3>
<p>To fulfil the objectives of our project regarding trading strategies, we have selected some indices and commonly used sector ETFs as examples:   </p>
<table>
<thead>
<tr>
<th>Ticker</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^GSPC</code></td>
<td>S&amp;P 500</td>
</tr>
<tr>
<td><code>^IXIC</code></td>
<td>NASDAQ</td>
</tr>
<tr>
<td><code>SPY</code></td>
<td>S&amp;P 500 ETF</td>
</tr>
<tr>
<td><code>QQQ</code></td>
<td>NASDAQ ETF</td>
</tr>
<tr>
<td><code>XLK</code></td>
<td>Tech Sector ETF</td>
</tr>
<tr>
<td><code>XLF</code></td>
<td>Financials ETF</td>
</tr>
<tr>
<td><code>XLE</code></td>
<td>Energy ETF</td>
</tr>
<tr>
<td><code>^VIX</code></td>
<td>Market Volatility</td>
</tr>
</tbody>
</table>
<ul>
<li>Obtain historical data (Open/High/Low/Close/Adj Close/Volume) from <strong>Yahoo Finance</strong>.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">tickers</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;^GSPC&#39;</span><span class="p">,</span>    <span class="c1"># S&amp;P 500</span>
    <span class="s1">&#39;^IXIC&#39;</span><span class="p">,</span>    <span class="c1"># NASDAQ</span>
    <span class="s1">&#39;SPY&#39;</span><span class="p">,</span>      <span class="c1"># SPY (S&amp;P 500 ETF)</span>
    <span class="s1">&#39;QQQ&#39;</span><span class="p">,</span>      <span class="c1"># QQQ (NASDAQ ETF)</span>
    <span class="s1">&#39;XLK&#39;</span><span class="p">,</span>      <span class="c1"># Tech Sector ETF</span>
    <span class="s1">&#39;XLF&#39;</span><span class="p">,</span>      <span class="c1"># Financials ETF</span>
    <span class="s1">&#39;XLE&#39;</span><span class="p">,</span>      <span class="c1"># Energy ETF</span>
    <span class="s1">&#39;^VIX&#39;</span><span class="p">,</span>     <span class="c1"># Market Volatility (VIX)&quot;</span>
<span class="p">]</span>

<span class="n">Symbol</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;S&amp;P500&#39;</span><span class="p">,</span> <span class="s1">&#39;NASDAQ&#39;</span><span class="p">,</span> <span class="s1">&#39;SPY&#39;</span><span class="p">,</span> <span class="s1">&#39;QQQ&#39;</span><span class="p">,</span> <span class="s1">&#39;Tech_ETF&#39;</span><span class="p">,</span> <span class="s1">&#39;Financials_ETF&#39;</span><span class="p">,</span> <span class="s1">&#39;Energy_ETF&#39;</span><span class="p">,</span> <span class="s1">&#39;VIX&#39;</span><span class="p">]</span>

<span class="c1"># Define date range (e.g., past 5 years)</span>
<span class="n">start_date</span> <span class="o">=</span> <span class="s1">&#39;2019-01-01&#39;</span>
<span class="n">end_date</span> <span class="o">=</span> <span class="s1">&#39;2023-12-31&#39;</span>

<span class="c1"># Fetch data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">yf</span><span class="o">.</span><span class="n">download</span><span class="p">(</span>
    <span class="n">tickers</span><span class="o">=</span><span class="n">tickers</span><span class="p">,</span>
    <span class="n">start</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span>
    <span class="n">end</span><span class="o">=</span><span class="n">end_date</span><span class="p">,</span>
    <span class="c1"># Optional: Adjust granularity (default is daily)</span>
    <span class="n">interval</span><span class="o">=</span><span class="s1">&#39;1d&#39;</span><span class="p">,</span>  <span class="c1"># &#39;1d&#39;, &#39;1wk&#39;, &#39;1mo&#39;</span>
    <span class="c1"># Fetch adjusted close prices to account for splits/dividends</span>
    <span class="n">auto_adjust</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>

<ul>
<li>Extract <strong>"Adj Close"</strong> for all tickers.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">adj_close</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Adj Close&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
<span class="n">adj_close</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">Symbol</span>
</code></pre></div>

<ul>
<li>Calculate <strong>daily percentage returns</strong> and <strong>cumulative returns</strong>(assuming reinvestment).</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">daily_returns</span> <span class="o">=</span> <span class="n">adj_close</span><span class="o">.</span><span class="n">pct_change</span><span class="p">()</span> <span class="o">*</span> <span class="mi">100</span>  <span class="c1"># Returns in percentage</span>
<span class="n">daily_returns</span> <span class="o">=</span> <span class="n">daily_returns</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>  <span class="c1"># Remove first row (NaN)</span>

<span class="c1"># Calculate cumulative returns (assuming reinvestment)</span>
<span class="n">cumulative_returns</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">daily_returns</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">cumprod</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div>

<h3>Generating csv file</h3>
<div class="highlight"><pre><span></span><code><span class="n">daily_returns</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;daily_returns.csv&#39;</span><span class="p">)</span>
<span class="n">adj_close</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;adjusted_close_prices.csv&#39;</span><span class="p">)</span>
</code></pre></div>

<h3>Visualization</h3>
<ul>
<li><strong>Plot Cumulative Returns</strong></li>
</ul>
<p><img alt="image six" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/images/SFinx_02_image-descriptionsix.png"> </p>
<ul>
<li><strong>Plot Correlation Heatmap</strong></li>
</ul>
<p><img alt="image seven" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/images/SFinx_02_image-descriptionseven.png"> </p>
<ul>
<li><strong>Descriptive Statistics of Daily Returns</strong></li>
</ul>
<p><img alt="image eight" src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/images/SFinx_02_image-descriptioneight.png"> </p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>


             
 
            
            
            







            <hr/>
        </div>
        <section id="article-sidebar" class="span2">
            <h4>Published</h4>
            <time itemprop="dateCreated" datetime="2025-03-10T00:00:00+08:00">Mon 10 March 2025</time>
            <h4>Category</h4>
            <a class="category-link" href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/categories.html#progress-report-2-ref">Progress Report 2</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/tags.html#group-sfinx-ref">Group "SFinx"
                    <span class="superscript">2</span>
</a></li>
            </ul>
<h4>Contact</h4>
<div id="sidebar-social-link">
    <a href="https://github.com/buehlmaier/MFIN7036-student-blog-2025-01" title="" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="GitHub" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#1B1817"/><path fill="#fff" d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
    </a>
</div>
            





            





        </section>
</div>
</article>
<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides.
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>                    </div>
                    <div class="span1"></div>
                </div>
            </div>
        </div>
<footer>




    <div id="fpowered">
        Powered by: <a href="http://getpelican.com/" title="Pelican Home Page" target="_blank" rel="nofollow noopener noreferrer">Pelican</a>
        Theme: <a href="https://elegant.oncrashreboot.com/" title="Theme Elegant Home Page" target="_blank" rel="nofollow noopener noreferrer">Elegant</a>
    </div>
</footer>            <script src="//code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script src="https://buehlmaier.github.io/MFIN7036-student-blog-2025-01/theme/js/elegant.prod.9e9d5ce754.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    <script>
    (function () {
        if (window.location.hash.match(/^#comment-\d+$/)) {
            $('#comment_thread').collapse('show');
        }
    })();
    window.onhashchange=function(){
        if (window.location.hash.match(/^#comment-\d+$/))
            window.location.reload(true);
    }
    $('#comment_thread').on('shown', function () {
        var link = document.getElementById('comment-accordion-toggle');
        var old_innerHTML = link.innerHTML;
        $(link).fadeOut(200, function() {
            $(this).text('Click here to hide comments').fadeIn(200);
        });
        $('#comment_thread').on('hidden', function () {
            $(link).fadeOut(200, function() {
                $(this).text(old_innerHTML).fadeIn(200);
            });
        })
    })
</script>

    </body>
    <!-- Theme: Elegant built for Pelican
        License : MIT -->
</html>